Description: Don't use net_dev after dev_put
 dev_put allows a device to be freed when all its references are dropped. After
 that we are not allowed to access that information anymore. Access to the data
 structure of a net_device must be surrounded a dev_hold and ended using
 dev_put.
 .
 batman-adv adds a device to its own management structure in
 hardif_add_interface and will release it in hardif_remove_interface. Thus it
 must hold a reference all the time between those functions to prevent any
 access to the already released net_device structure.
Author: Sven Eckelmann <sven.eckelmann@gmx.de>
Bug-Debian: http://bugs.debian.org/593472

---
diff --git a/hard-interface.c b/hard-interface.c
index 67f5ed6ae76bb075fb400bc117d37b4e5658aa0a..60e8a56423766e2e69f55db561e42ede8c609a61 100644
--- a/hard-interface.c
+++ b/hard-interface.c
@@ -195,8 +195,6 @@ static void hardif_activate_interface(struct bat_priv *bat_priv,
 	if (batman_if->if_status != IF_INACTIVE)
 		return;
 
-	dev_hold(batman_if->net_dev);
-
 	update_mac_addresses(batman_if);
 	batman_if->if_status = IF_TO_BE_ACTIVATED;
 
@@ -223,8 +221,6 @@ static void hardif_deactivate_interface(struct batman_if *batman_if)
 	   (batman_if->if_status != IF_TO_BE_ACTIVATED))
 		return;
 
-	dev_put(batman_if->net_dev);
-
 	batman_if->if_status = IF_INACTIVE;
 
 	printk(KERN_INFO "batman-adv:Interface deactivated: %s\n",
@@ -322,12 +318,14 @@ static struct batman_if *hardif_add_interface(struct net_device *net_dev)
 	if (ret != 1)
 		goto out;
 
+	dev_hold(net_dev);
+
 	batman_if = kmalloc(sizeof(struct batman_if), GFP_ATOMIC);
 	if (!batman_if) {
 		printk(KERN_ERR "batman-adv:"
 		       "Can't add interface (%s): out of memory\n",
 		       net_dev->name);
-		goto out;
+		goto release_dev;
 	}
 
 	batman_if->dev = kstrdup(net_dev->name, GFP_ATOMIC);
@@ -351,6 +349,8 @@ free_dev:
 	kfree(batman_if->dev);
 free_if:
 	kfree(batman_if);
+release_dev:
+	dev_put(net_dev);
 out:
 	return NULL;
 }
@@ -379,6 +379,7 @@ static void hardif_remove_interface(struct batman_if *batman_if)
 	batman_if->if_status = IF_TO_BE_REMOVED;
 	list_del_rcu(&batman_if->list);
 	sysfs_del_hardif(&batman_if->hardif_obj);
+	dev_put(batman_if->net_dev);
 	call_rcu(&batman_if->rcu, hardif_free_interface);
 }
 
