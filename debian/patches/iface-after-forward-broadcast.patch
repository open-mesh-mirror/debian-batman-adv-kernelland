Description: Don't access random memory after forwarding broadcast
 B.A.T.M.A.N. advanced iterates over every known interface when receiving
 data and tries to forward as much as possible data from the same
 interface as possible using a while-loop inside the outer loop.
 When it receives a broadcast ethernet frame which needs to be forwarded
 again it will try to send it to every known interface again. This loop
 is inside the first one and used the same pos variable as the outer
 loop. After the inner loop has finished it will point to a memory
 location which is not part of the interface list, but the while loop
 starts again and tries to access this memory region without knowing what
 it is and to what it belongs. This could lead to a kernel oops or any
 kind of other unspecified behavior of the kernel.
 The inner loop should use a seperate position variable to iterate over
 all interfaces for the broadcast.
Bug: http://open-mesh.net/ticket/125
Forwarded: https://lists.open-mesh.net/pipermail/b.a.t.m.a.n/2009-April/002502.html
Author: Sven Eckelmann <sven.eckelmann@gmx.de>

---
diff --git a/routing.c b/routing.c
index f0871a4fe6da3315998d9a21e642b16800c79460..74e3cdb3d0f07815cb9c8a5dbfc22a7c5f2f71c7 100644
--- a/routing.c
+++ b/routing.c
@@ -577,7 +577,7 @@ int receive_raw_packet(struct socket *raw_sock, unsigned char *packet_buff, int
 
 int packet_recv_thread(void *data)
 {
-	struct batman_if *batman_if;
+	struct batman_if *batman_if, *batman_bcastif;
 	struct ethhdr *ethhdr;
 	struct batman_packet *batman_packet;
 	struct unicast_packet *unicast_packet;
@@ -864,9 +864,9 @@ int packet_recv_thread(void *data)
 						interface_rx(soft_device, packet_buff + sizeof(struct ethhdr) + sizeof(struct bcast_packet), result - sizeof(struct ethhdr) - sizeof(struct bcast_packet));
 
 						/* rebroadcast packet */
-						list_for_each_entry_rcu(batman_if, &if_list, list) {
+						list_for_each_entry_rcu(batman_bcastif, &if_list, list) {
 
-							send_raw_packet(packet_buff + sizeof(struct ethhdr), result - sizeof(struct ethhdr), batman_if->net_dev->dev_addr, broadcastAddr, batman_if);
+							send_raw_packet(packet_buff + sizeof(struct ethhdr), result - sizeof(struct ethhdr), batman_bcastif->net_dev->dev_addr, broadcastAddr, batman_bcastif);
 						}
 
 					} else {
